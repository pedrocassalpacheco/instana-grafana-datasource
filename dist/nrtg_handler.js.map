{"version":3,"sources":["../src/nrtg_handler.js"],"names":["moment","NRTGHandler","options","datasource","pollingInterval","subscribers","startTime","endTime","datapoints","_this","backendSrv","datasourceRequest","url","method","params","resourceId","report","then","handleCollectionDetails","response","data","nrtgCollectionDetails","collectionTaskId","poll","bind","setInterval","self","pollInProgress","nrtCollectionTaskId","handleMeasurementSets","measurement_sets","measurementSets","i","nsets","nsubscribers","length","measurements","k","nmeasurements","timeStamp","push","value","seriesList","target","next","range","from","to"],"mappings":"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","file":"nrtg_handler.js","sourcesContent":["import moment from 'moment';\n\n/*\nPrototype code used to stream metrics from NRTG to the Grafana's streaming APIs.\n\nYou can use the following to invoke this from a datasource:\n  query(options) {\n    // NRTG Streaming\n    var handler = new NRTGHandler(options, this);\n    handler.start();\n    return Promise.resolve(handler);\n  }\n*/\nexport class NRTGHandler {\n\n  constructor(options, datasource) {\n    this.options = options;\n    this.datasource = datasource;\n    this.pollingInterval = 1000;\n    this.subscribers = [];\n\n    this.startTime = null;\n    this.endTime = null;\n    this.datapoints = [];\n  }\n\n  start() {\n    var _this = this;\n    this.datasource.backendSrv.datasourceRequest({\n      url: this.datasource.url + '/nrt/starter',\n      method: 'GET',\n      params: {\n        resourceId: \"node[10].nodeSnmp[]\",\n        report: \"mib2.tcpopen\"\n      }\n    }).then(response => {\n      _this.handleCollectionDetails(response.data);\n    });\n  }\n\n  handleCollectionDetails(nrtgCollectionDetails) {\n    var _this = this;\n\n    // Start polling\n    this.collectionTaskId = nrtgCollectionDetails.collectionTaskId;\n    var poll = function () {_this.poll();}.bind(_this);\n    poll();\n    setInterval(poll, _this.pollingInterval);\n  }\n\n  poll() {\n    var self = this;\n    if (self.pollInProgress === true) {\n      // If another poll is already in progress, then skip this one\n      return;\n    }\n\n    self.pollInProgress = true;\n    this.datasource.backendSrv.datasourceRequest({\n      url: this.datasource.url + '/nrt/starter',\n      method: 'GET',\n      params: {\n        poll: \"true\",\n        nrtCollectionTaskId: self.collectionTaskId\n      }\n    }).then(response => {\n      self.pollInProgress = false;\n      self.handleMeasurementSets(response.data.measurement_sets);\n    });\n  }\n\n  handleMeasurementSets(measurementSets) {\n    var i, nsets, nsubscribers;\n    for (i = 0, nsets = measurementSets.length; i < nsets; i++) {\n      var measurements = measurementSets[i];\n      for (var k = 0, nmeasurements = measurements.length; k < nmeasurements; k++) {\n        if (!this.startTime) {\n          this.startTime = measurements[k].timeStamp;\n        }\n        this.endTime = measurements[k].timeStamp;\n        this.datapoints.push([measurements[k].value, measurements[k].timeStamp]);\n      }\n    }\n\n    if (!this.startTime) {\n      return;\n    }\n\n    var seriesList = [{\n      target: \"x\",\n      datapoints: this.datapoints\n    }];\n\n    for (i = 0, nsubscribers = this.subscribers.length; i < nsubscribers; i++) {\n      this.subscribers[i].next({data: seriesList, range: {from: moment(this.startTime), to: moment(this.endTime)}});\n    }\n  }\n\n  subscribe(options) {\n    this.subscribers.push(options);\n  }\n}\n"]}